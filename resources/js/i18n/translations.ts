type TranslationValue = string | { [key: string]: string | TranslationValue } | [];
type Translations = { [language: string]: { [key: string]: TranslationValue } };

const translations: Translations = {
    de: {
        auth: {
            failed: 'Diese Kombination aus Zugangsdaten wurde nicht in unserer Datenbank gefunden.',
            password: 'Das eingegebene Passwort ist nicht korrekt.',
            throttle: 'Zu viele Loginversuche. Versuchen Sie es bitte in {seconds} Sekunden nochmal.',
        },
        pagination: {
            next: 'Weiter &raquo;',
            previous: '&laquo; Zurück',
        },
        passwords: {
            reset: 'Das Passwort wurde zurückgesetzt!',
            sent: 'Passworterinnerung wurde gesendet!',
            throttled: 'Bitte warten Sie, bevor Sie es erneut versuchen.',
            token: 'Der Passwort-Wiederherstellungs-Schlüssel ist ungültig oder abgelaufen.',
            user: 'Es konnte leider kein Nutzer mit dieser E-Mail-Adresse gefunden werden.',
        },
        validation: {
            accepted: '{attribute} muss akzeptiert werden.',
            accepted_if: '{attribute} muss akzeptiert werden, wenn {other} {value} ist.',
            active_url: '{attribute} ist keine gültige Internet-Adresse.',
            after: '{attribute} muss ein Datum nach {date} sein.',
            after_or_equal: '{attribute} muss ein Datum nach {date} oder gleich {date} sein.',
            alpha: '{attribute} darf nur aus Buchstaben bestehen.',
            alpha_dash: '{attribute} darf nur aus Buchstaben, Zahlen, Binde- und Unterstrichen bestehen.',
            alpha_num: '{attribute} darf nur aus Buchstaben und Zahlen bestehen.',
            array: '{attribute} muss ein Array sein.',
            attached: '{attribute} ist bereits angehängt.',
            before: '{attribute} muss ein Datum vor {date} sein.',
            before_or_equal: '{attribute} muss ein Datum vor {date} oder gleich {date} sein.',
            between: {
                array: '{attribute} muss zwischen {min} & {max} Elemente haben.',
                file: '{attribute} muss zwischen {min} & {max} Kilobytes groß sein.',
                numeric: '{attribute} muss zwischen {min} & {max} liegen.',
                string: '{attribute} muss zwischen {min} & {max} Zeichen lang sein.',
            },
            boolean: "{attribute} muss entweder 'true' oder 'false' sein.",
            confirmed: '{attribute} stimmt nicht mit der Bestätigung überein.',
            current_password: 'Das Passwort ist falsch.',
            date: '{attribute} muss ein gültiges Datum sein.',
            date_equals: '{attribute} muss ein Datum gleich {date} sein.',
            date_format: '{attribute} entspricht nicht dem gültigen Format für {format}.',
            declined: '{attribute} muss abgelehnt werden.',
            declined_if: '{attribute} muss abgelehnt werden wenn {other} {value} ist.',
            different: '{attribute} und {other} müssen sich unterscheiden.',
            digits: '{attribute} muss {digits} Stellen haben.',
            digits_between: '{attribute} muss zwischen {min} und {max} Stellen haben.',
            dimensions: '{attribute} hat ungültige Bildabmessungen.',
            distinct: '{attribute} beinhaltet einen bereits vorhandenen Wert.',
            email: '{attribute} muss eine gültige E-Mail-Adresse sein.',
            ends_with: '{attribute} muss eine der folgenden Endungen aufweisen: {values}',
            exists: 'Der gewählte Wert für {attribute} ist ungültig.',
            file: '{attribute} muss eine Datei sein.',
            filled: '{attribute} muss ausgefüllt sein.',
            gt: {
                array: '{attribute} muss mehr als {value} Elemente haben.',
                file: '{attribute} muss größer als {value} Kilobytes sein.',
                numeric: '{attribute} muss größer als {value} sein.',
                string: '{attribute} muss länger als {value} Zeichen sein.',
            },
            gte: {
                array: '{attribute} muss mindestens {value} Elemente haben.',
                file: '{attribute} muss größer oder gleich {value} Kilobytes sein.',
                numeric: '{attribute} muss größer oder gleich {value} sein.',
                string: '{attribute} muss mindestens {value} Zeichen lang sein.',
            },
            image: '{attribute} muss ein Bild sein.',
            in: 'Der gewählte Wert für {attribute} ist ungültig.',
            in_array: 'Der gewählte Wert für {attribute} kommt nicht in {other} vor.',
            indisposable: 'Einweg-E-Mail-Adressen sind nicht zulässig.',
            integer: '{attribute} muss eine ganze Zahl sein.',
            ip: '{attribute} muss eine gültige IP-Adresse sein.',
            ipv4: '{attribute} muss eine gültige IPv4-Adresse sein.',
            ipv6: '{attribute} muss eine gültige IPv6-Adresse sein.',
            json: '{attribute} muss ein gültiger JSON-String sein.',
            lt: {
                array: '{attribute} muss weniger als {value} Elemente haben.',
                file: '{attribute} muss kleiner als {value} Kilobytes sein.',
                numeric: '{attribute} muss kleiner als {value} sein.',
                string: '{attribute} muss kürzer als {value} Zeichen sein.',
            },
            lte: {
                array: '{attribute} darf maximal {value} Elemente haben.',
                file: '{attribute} muss kleiner oder gleich {value} Kilobytes sein.',
                numeric: '{attribute} muss kleiner oder gleich {value} sein.',
                string: '{attribute} darf maximal {value} Zeichen lang sein.',
            },
            max: {
                array: '{attribute} darf maximal {max} Elemente haben.',
                file: '{attribute} darf maximal {max} Kilobytes groß sein.',
                numeric: '{attribute} darf maximal {max} sein.',
                string: '{attribute} darf maximal {max} Zeichen haben.',
            },
            mimes: '{attribute} muss den Dateityp {values} haben.',
            mimetypes: '{attribute} muss den Dateityp {values} haben.',
            min: {
                array: '{attribute} muss mindestens {min} Elemente haben.',
                file: '{attribute} muss mindestens {min} Kilobytes groß sein.',
                numeric: '{attribute} muss mindestens {min} sein.',
                string: '{attribute} muss mindestens {min} Zeichen lang sein.',
            },
            multiple_of: '{attribute} muss ein Vielfaches von {value} sein.',
            not_in: 'Der gewählte Wert für {attribute} ist ungültig.',
            not_regex: '{attribute} hat ein ungültiges Format.',
            numeric: '{attribute} muss eine Zahl sein.',
            password: {
                letters: '{attribute} muss mindestens einen Buchstaben enthalten.',
                mixed: '{attribute} muss mindestens einen Großbuchstaben und einen Kleinbuchstaben enthalten.',
                numbers: '{attribute} muss mindestens eine Ziffer enthalten.',
                symbols: '{attribute} muss mindestens ein Sonderzeichen enthalten.',
                uncompromised: 'The given {attribute} has appeared in a data leak. Please choose a different {attribute}.',
            },
            phone: '{attribute} muss eine gültige Telefonnummer sein.',
            present: '{attribute} muss vorhanden sein.',
            prohibited: '{attribute} ist unzulässig.',
            prohibited_if: '{attribute} ist unzulässig, wenn {other} {value} ist.',
            prohibited_if_accepted: 'Das Feld {attribute} ist unzulässig, wenn {other} gewählt ist.',
            prohibited_if_declined: 'Das Feld {attribute} ist unzulässig, wenn {other} abgelehnt ist.',
            prohibited_unless: '{attribute} ist unzulässig, wenn {other} nicht {values} ist.',
            prohibits: '{attribute} verbietet die Angabe von {other}.',
            regex: '{attribute} Format ist ungültig.',
            relatable: '{attribute} kann nicht mit dieser Ressource verbunden werden.',
            required: '{attribute} muss ausgefüllt werden.',
            required_if: '{attribute} muss ausgefüllt werden, wenn {other} den Wert {value} hat.',
            required_unless: '{attribute} muss ausgefüllt werden, wenn {other} nicht den Wert {values} hat.',
            required_with: '{attribute} muss ausgefüllt werden, wenn {values} ausgefüllt wurde.',
            required_with_all: '{attribute} muss ausgefüllt werden, wenn {values} ausgefüllt wurde.',
            required_without: '{attribute} muss ausgefüllt werden, wenn {values} nicht ausgefüllt wurde.',
            required_without_all: '{attribute} muss ausgefüllt werden, wenn keines der Felder {values} ausgefüllt wurde.',
            same: '{attribute} und {other} müssen übereinstimmen.',
            size: {
                array: '{attribute} muss genau {size} Elemente haben.',
                file: '{attribute} muss {size} Kilobyte groß sein.',
                numeric: '{attribute} muss gleich {size} sein.',
                string: '{attribute} muss {size} Zeichen lang sein.',
            },
            starts_with: '{attribute} muss mit einem der folgenden Anfänge aufweisen: {values}',
            string: '{attribute} muss ein String sein.',
            timezone: '{attribute} muss eine gültige Zeitzone sein.',
            unique: '{attribute} ist bereits vergeben.',
            uploaded: '{attribute} konnte nicht hochgeladen werden.',
            url: '{attribute} muss eine URL sein.',
            uuid: '{attribute} muss ein UUID sein.',
            custom: {
                'attribute-name': {
                    'rule-name': 'custom-message',
                },
            },
            attributes: {
                street: 'Straße und Hausnummer',
                phone_number: 'Telefonnummer',
            },
        },
    },
    en: {
        auth: {
            failed: 'These credentials do not match our records.',
            password: 'The provided password is incorrect.',
            throttle: 'Too many login attempts. Please try again in {seconds} seconds.',
        },
        pagination: {
            previous: '&laquo; Previous',
            next: 'Next &raquo;',
        },
        passwords: {
            reset: 'Your password has been reset.',
            sent: 'We have emailed your password reset link.',
            throttled: 'Please wait before retrying.',
            token: 'This password reset token is invalid.',
            user: "We can't find a user with that email address.",
        },
        validation: {
            accepted: 'The {attribute} field must be accepted.',
            accepted_if: 'The {attribute} field must be accepted when {other} is {value}.',
            active_url: 'The {attribute} field must be a valid URL.',
            after: 'The {attribute} field must be a date after {date}.',
            after_or_equal: 'The {attribute} field must be a date after or equal to {date}.',
            alpha: 'The {attribute} field must only contain letters.',
            alpha_dash: 'The {attribute} field must only contain letters, numbers, dashes, and underscores.',
            alpha_num: 'The {attribute} field must only contain letters and numbers.',
            any_of: 'The {attribute} field is invalid.',
            array: 'The {attribute} field must be an array.',
            ascii: 'The {attribute} field must only contain single-byte alphanumeric characters and symbols.',
            before: 'The {attribute} field must be a date before {date}.',
            before_or_equal: 'The {attribute} field must be a date before or equal to {date}.',
            between: {
                array: 'The {attribute} field must have between {min} and {max} items.',
                file: 'The {attribute} field must be between {min} and {max} kilobytes.',
                numeric: 'The {attribute} field must be between {min} and {max}.',
                string: 'The {attribute} field must be between {min} and {max} characters.',
            },
            boolean: 'The {attribute} field must be true or false.',
            can: 'The {attribute} field contains an unauthorized value.',
            confirmed: 'The {attribute} field confirmation does not match.',
            contains: 'The {attribute} field is missing a required value.',
            current_password: 'The password is incorrect.',
            date: 'The {attribute} field must be a valid date.',
            date_equals: 'The {attribute} field must be a date equal to {date}.',
            date_format: 'The {attribute} field must match the format {format}.',
            decimal: 'The {attribute} field must have {decimal} decimal places.',
            declined: 'The {attribute} field must be declined.',
            declined_if: 'The {attribute} field must be declined when {other} is {value}.',
            different: 'The {attribute} field and {other} must be different.',
            digits: 'The {attribute} field must be {digits} digits.',
            digits_between: 'The {attribute} field must be between {min} and {max} digits.',
            dimensions: 'The {attribute} field has invalid image dimensions.',
            distinct: 'The {attribute} field has a duplicate value.',
            doesnt_end_with: 'The {attribute} field must not end with one of the following: {values}.',
            doesnt_start_with: 'The {attribute} field must not start with one of the following: {values}.',
            email: 'The {attribute} field must be a valid email address.',
            ends_with: 'The {attribute} field must end with one of the following: {values}.',
            enum: 'The selected {attribute} is invalid.',
            exists: 'The selected {attribute} is invalid.',
            extensions: 'The {attribute} field must have one of the following extensions: {values}.',
            file: 'The {attribute} field must be a file.',
            filled: 'The {attribute} field must have a value.',
            gt: {
                array: 'The {attribute} field must have more than {value} items.',
                file: 'The {attribute} field must be greater than {value} kilobytes.',
                numeric: 'The {attribute} field must be greater than {value}.',
                string: 'The {attribute} field must be greater than {value} characters.',
            },
            gte: {
                array: 'The {attribute} field must have {value} items or more.',
                file: 'The {attribute} field must be greater than or equal to {value} kilobytes.',
                numeric: 'The {attribute} field must be greater than or equal to {value}.',
                string: 'The {attribute} field must be greater than or equal to {value} characters.',
            },
            hex_color: 'The {attribute} field must be a valid hexadecimal color.',
            image: 'The {attribute} field must be an image.',
            in: 'The selected {attribute} is invalid.',
            in_array: 'The {attribute} field must exist in {other}.',
            integer: 'The {attribute} field must be an integer.',
            ip: 'The {attribute} field must be a valid IP address.',
            ipv4: 'The {attribute} field must be a valid IPv4 address.',
            ipv6: 'The {attribute} field must be a valid IPv6 address.',
            json: 'The {attribute} field must be a valid JSON string.',
            list: 'The {attribute} field must be a list.',
            lowercase: 'The {attribute} field must be lowercase.',
            lt: {
                array: 'The {attribute} field must have less than {value} items.',
                file: 'The {attribute} field must be less than {value} kilobytes.',
                numeric: 'The {attribute} field must be less than {value}.',
                string: 'The {attribute} field must be less than {value} characters.',
            },
            lte: {
                array: 'The {attribute} field must not have more than {value} items.',
                file: 'The {attribute} field must be less than or equal to {value} kilobytes.',
                numeric: 'The {attribute} field must be less than or equal to {value}.',
                string: 'The {attribute} field must be less than or equal to {value} characters.',
            },
            mac_address: 'The {attribute} field must be a valid MAC address.',
            max: {
                array: 'The {attribute} field must not have more than {max} items.',
                file: 'The {attribute} field must not be greater than {max} kilobytes.',
                numeric: 'The {attribute} field must not be greater than {max}.',
                string: 'The {attribute} field must not be greater than {max} characters.',
            },
            max_digits: 'The {attribute} field must not have more than {max} digits.',
            mimes: 'The {attribute} field must be a file of type: {values}.',
            mimetypes: 'The {attribute} field must be a file of type: {values}.',
            min: {
                array: 'The {attribute} field must have at least {min} items.',
                file: 'The {attribute} field must be at least {min} kilobytes.',
                numeric: 'The {attribute} field must be at least {min}.',
                string: 'The {attribute} field must be at least {min} characters.',
            },
            min_digits: 'The {attribute} field must have at least {min} digits.',
            missing: 'The {attribute} field must be missing.',
            missing_if: 'The {attribute} field must be missing when {other} is {value}.',
            missing_unless: 'The {attribute} field must be missing unless {other} is {value}.',
            missing_with: 'The {attribute} field must be missing when {values} is present.',
            missing_with_all: 'The {attribute} field must be missing when {values} are present.',
            multiple_of: 'The {attribute} field must be a multiple of {value}.',
            not_in: 'The selected {attribute} is invalid.',
            not_regex: 'The {attribute} field format is invalid.',
            numeric: 'The {attribute} field must be a number.',
            password: {
                letters: 'The {attribute} field must contain at least one letter.',
                mixed: 'The {attribute} field must contain at least one uppercase and one lowercase letter.',
                numbers: 'The {attribute} field must contain at least one number.',
                symbols: 'The {attribute} field must contain at least one symbol.',
                uncompromised: 'The given {attribute} has appeared in a data leak. Please choose a different {attribute}.',
            },
            present: 'The {attribute} field must be present.',
            present_if: 'The {attribute} field must be present when {other} is {value}.',
            present_unless: 'The {attribute} field must be present unless {other} is {value}.',
            present_with: 'The {attribute} field must be present when {values} is present.',
            present_with_all: 'The {attribute} field must be present when {values} are present.',
            prohibited: 'The {attribute} field is prohibited.',
            prohibited_if: 'The {attribute} field is prohibited when {other} is {value}.',
            prohibited_if_accepted: 'The {attribute} field is prohibited when {other} is accepted.',
            prohibited_if_declined: 'The {attribute} field is prohibited when {other} is declined.',
            prohibited_unless: 'The {attribute} field is prohibited unless {other} is in {values}.',
            prohibits: 'The {attribute} field prohibits {other} from being present.',
            regex: 'The {attribute} field format is invalid.',
            required: 'The {attribute} field is required.',
            required_array_keys: 'The {attribute} field must contain entries for: {values}.',
            required_if: 'The {attribute} field is required when {other} is {value}.',
            required_if_accepted: 'The {attribute} field is required when {other} is accepted.',
            required_if_declined: 'The {attribute} field is required when {other} is declined.',
            required_unless: 'The {attribute} field is required unless {other} is in {values}.',
            required_with: 'The {attribute} field is required when {values} is present.',
            required_with_all: 'The {attribute} field is required when {values} are present.',
            required_without: 'The {attribute} field is required when {values} is not present.',
            required_without_all: 'The {attribute} field is required when none of {values} are present.',
            same: 'The {attribute} field must match {other}.',
            size: {
                array: 'The {attribute} field must contain {size} items.',
                file: 'The {attribute} field must be {size} kilobytes.',
                numeric: 'The {attribute} field must be {size}.',
                string: 'The {attribute} field must be {size} characters.',
            },
            starts_with: 'The {attribute} field must start with one of the following: {values}.',
            string: 'The {attribute} field must be a string.',
            timezone: 'The {attribute} field must be a valid timezone.',
            unique: 'The {attribute} has already been taken.',
            uploaded: 'The {attribute} failed to upload.',
            uppercase: 'The {attribute} field must be uppercase.',
            url: 'The {attribute} field must be a valid URL.',
            ulid: 'The {attribute} field must be a valid ULID.',
            uuid: 'The {attribute} field must be a valid UUID.',
            custom: {
                'attribute-name': {
                    'rule-name': 'custom-message',
                },
            },
            attributes: [],
        },
    },
};
export default translations;
